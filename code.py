# requirements.txt content:
# fastapi==0.111.0
# uvicorn[standard]==0.30.1
# pydantic==2.7.4

from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import List, Dict, Optional

# --- 1. FastAPI Application Initialization ---
# Create an instance of the FastAPI application.
# This is the main entry point for your API.
app = FastAPI(
    title="Supplier API",
    description="A boilerplate backend for managing supplier information.",
    version="0.1.0",
)

# --- 2. Data Models (using Pydantic) ---
# Pydantic models define the structure of your data.
# They are used for request body validation, response serialization, and documentation.

class ContactPerson(BaseModel):
    """
    Represents a contact person for a supplier.
    """
    name: str = Field(..., example="Jane Doe", description="Full name of the contact person.")
    email: str = Field(..., example="jane.doe@example.com", description="Email address of the contact person.")
    phone: Optional[str] = Field(None, example="+1-555-123-4567", description="Optional phone number.")

class SupplierBase(BaseModel):
    """
    Base model for creating or updating a supplier.
    Contains common fields.
    """
    name: str = Field(..., min_length=3, max_length=100, example="Acme Supplies Inc.", description="Name of the supplier.")
    industry: str = Field(..., example="Manufacturing", description="Industry the supplier operates in.")
    contact_person: ContactPerson
    is_active: bool = Field(True, description="Whether the supplier is currently active.")

class SupplierCreate(SupplierBase):
    """
    Model for creating a new supplier.
    Inherits from SupplierBase.
    """
    # No additional fields needed for creation beyond SupplierBase,
    # but you might add unique constraints or initial values here if applicable.
    pass

class Supplier(SupplierBase):
    """
    Full supplier model, including fields generated by the system (like ID).
    """
    id: int = Field(..., example=1, description="Unique identifier for the supplier.")

    class Config:
        # This nested class provides configurations for Pydantic.
        # It's useful for integration with ORMs or other systems that don't return dicts.
        from_attributes = True # Allow Pydantic to read data from attributes (e.g., for SQLAlchemy models)
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "Global Tech Solutions",
                "industry": "IT Services",
                "contact_person": {
                    "name": "John Smith",
                    "email": "john.smith@globaltech.com",
                    "phone": "555-987-6543"
                },
                "is_active": True
            }
        }

# --- 3. In-memory "Database" (for demonstration purposes) ---
# In a real application, this would be a database connection (PostgreSQL, MySQL, MongoDB, etc.).
# This dictionary simulates storing supplier records.
fake_db: Dict[int, Supplier] = {}
next_id = 1

# --- 4. Dependency Injection ---
# FastAPI's dependency injection system helps manage shared resources.
# Here, we'll use it to simulate getting the "database" connection.
def get_db():
    """
    Dependency that yields the fake database.
    In a real app, this would set up and tear down a DB session.
    """
    try:
        yield fake_db
    finally:
        # Cleanup code can go here if needed (e.g., closing DB connection)
        pass

# --- 5. API Endpoints ---
# Define the routes and their associated logic.

@app.get("/")
async def read_root():
    """
    Root endpoint for a simple health check or welcome message.
    """
    return {"message": "Welcome to the Supplier API!"}

@app.get("/suppliers/", response_model=List[Supplier])
async def get_all_suppliers(db: Dict[int, Supplier] = Depends(get_db)):
    """
    Retrieve a list of all registered suppliers.
    """
    return list(db.values())

@app.get("/suppliers/{supplier_id}", response_model=Supplier)
async def get_supplier_by_id(supplier_id: int, db: Dict[int, Supplier] = Depends(get_db)):
    """
    Retrieve a single supplier by its unique ID.
    Raises a 404 error if the supplier is not found.
    """
    supplier = db.get(supplier_id)
    if supplier is None:
        raise HTTPException(status_code=404, detail="Supplier not found")
    return supplier

@app.post("/suppliers/", response_model=Supplier, status_code=201)
async def create_supplier(supplier: SupplierCreate, db: Dict[int, Supplier] = Depends(get_db)):
    """
    Create a new supplier.
    The supplier data is provided in the request body.
    """
    global next_id
    new_supplier = Supplier(id=next_id, **supplier.model_dump())
    db[next_id] = new_supplier
    next_id += 1
    return new_supplier

@app.put("/suppliers/{supplier_id}", response_model=Supplier)
async def update_supplier(
    supplier_id: int, updated_supplier: SupplierCreate, db: Dict[int, Supplier] = Depends(get_db)
):
    """
    Update an existing supplier's information by ID.
    Raises a 404 error if the supplier is not found.
    """
    if supplier_id not in db:
        raise HTTPException(status_code=404, detail="Supplier not found")

    existing_supplier = db[supplier_id]
    # Update fields from the incoming data
    updated_data = updated_supplier.model_dump(exclude_unset=True) # exclude_unset ensures only provided fields are updated
    for key, value in updated_data.items():
        setattr(existing_supplier, key, value) # This updates the Pydantic model directly.
        
    db[supplier_id] = existing_supplier # Reassign updated supplier to update in db
    return existing_supplier

@app.delete("/suppliers/{supplier_id}", status_code=204)
async def delete_supplier(supplier_id: int, db: Dict[int, Supplier] = Depends(get_db)):
    """
    Delete a supplier by its ID.
    Returns 204 No Content on successful deletion.
    Raises a 404 error if the supplier is not found.
    """
    if supplier_id not in db:
        raise HTTPException(status_code=404, detail="Supplier not found")
    del db[supplier_id]
    return {"message": "Supplier deleted successfully"}


# --- 6. How to run the application (using Uvicorn) ---
# To run this API, save the code as `main.py` (or any other name).
# Ensure you have FastAPI and Uvicorn installed:
# pip install "fastapi[all]" uvicorn

# Then run from your terminal in the same directory:
# uvicorn main:app --reload

# The `--reload` flag enables auto-reloading of the server when code changes are detected.
# You can then access the API at http://127.0.0.1:8000
# And the interactive documentation (Swagger UI) at http://127.0.0.1:8000/docs
# Or ReDoc documentation at http://127.0.0.1:8000/redoc
